(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{136:function(e,a,s){"use strict";s.r(a);var o=s(4),t=Object(o.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Hash e Equals")]),e._v(" "),s("p",[e._v('Uma das duvidas mais comuns para os programadores que estão começando em java é sobre a dupla "equals e hashCode".O hashCode é uma ferramenta da JVM usada para montar a tabela de hash de modo correto.')]),e._v(" "),s("p",[e._v('"Ham? Do que você ta falando velho?"')]),e._v(" "),s("p",[e._v('Tabela Hash [ou Tabela de Dispersão ou Tabela de Espalhamento] é uma tabela onde as informações são armazenadas conforme um "numero hash" calculado com base nas propriedades da informação. Isso permite que seja muito rápido recuperar uma informação na tabela.')]),e._v(" "),s("p",[e._v("Vamos exemplificar o negócio: você tem uma tabela com as informações de todos os pacientes de um hospital. Se você fosse buscar um paciente em especial iria demorar um tempo (O(n) numa busca linear ou O(log N) para buscas binarias) o que pode ser extremamente ruim em uma situação real onde existe um volume de dados gigantescos. Usando uma tabela hash a busca reduz seu tempo de busca (O(1)) para qualquer situação, bastando apenas o calculo do valor hash na entrada e na saída da informação.")]),e._v(" "),s("p",[e._v("Um ultimo exemplo pra quem ainda não compreendeu, imagine que a tabela hash é um armário cheio de gavetas, todas com um numero na frente. Toda vez que você vai guardar alguma coisa nesse armário, primeiro se calcula um hash dessa informação [ o como a gente explica depois] e com esse número nós colocamos na gaveta especifica. Se alguns anos mais tarde precisar dessa informação, apenas calculando o hash nós podemos ir direto na gaveta certa!!!")]),e._v(" "),s("p",[e._v('"O LOKO CARA! Entendi essa parada mas... e se tiver mais de uma informação nessa gaveta?!"')]),e._v(" "),s("p",[e._v('Se entendeu a parada mesmo. A ideia de uma boa função hash é garantir que só ela esteja em uma determinada "gaveta", só que infelizmente isso nem sempre é possível. Quando mais de uma informação acabe em um mesmo '),s("strong",[e._v("bucket")]),e._v('[apenas uma outra forma de se referir a "gaveta" ] acontece o que chamamos de colisão na tabela hash. Ainda assim é a melhor estratégia, pois temos que procurar apenas entre poucos objetos ao invés daquela volumosa quantidade de antes.')]),e._v(" "),s("p",[e._v("Toda essa explicação de hash é algo independente da linguagem, tabelas hash podem ser usadas em diversos cenários onde exista a informação de armazenar e recuperar informações de modo otimizado e eficiente. O java se utiliza desses conceitos para melhorar suas estruturas e prover melhores buscas.")]),e._v(" "),s("p",[e._v('"Angeliski, se falou muito desse tal hash... onde entra o equals?"')]),e._v(" "),s("p",[e._v('Lembra que eu disse que pode haver uma colisão de informações? ou seja, podem ter dois dados num mesmo **bucket.**Através do método equals você pode determinar se os objetos são iguais. A ideia do equals é garantir que dois objetos são "significativamente iguais", ou seja, que os objetos tem uma valor igual dadas as suas propriedades.')]),e._v(" "),s("blockquote",[s("p",[e._v('"Falar é fácil, me mostre o código.\nLinus Torvalds"')])]),e._v(" "),s("h2",{attrs:{id:"como-implementar"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#como-implementar","aria-hidden":"true"}},[e._v("#")]),e._v(" "),s("strong",[e._v("Como implementar?")])]),e._v(" "),s("p",[e._v("{% codeblock lang:java Classe Pessoa %}\npublic class Pessoa {\nString nome;\nString sobrenome;\nString idade;\n}\n{% endcodeblock %}")]),e._v(" "),s("p",[e._v('Como podemos definir que duas pessoas são "significativamente iguais"? Vamos dizer que toda pessoa com o mesmo nome e com a mesma idade é igual, modificando nossa classe ela fica assim:')]),e._v(" "),s("p",[e._v("{% codeblock lang:java %}\npublic class Pessoa {\nString nome;\nString sobrenome;\nString idade;")]),e._v(" "),s("pre",[s("code",[e._v("@Override\npublic boolean equals(Object obj) {\n\tif (!(obj instanceof Pessoa))\n\t\treturn false;\n\tPessoa other = (Pessoa) obj;\n\tif (!this.nome.equals(other.nome) || !this.idade.equals(other.idade))\n\t\treturn false;\n\treturn true;\n}\n")])]),e._v(" "),s("p",[e._v("}\n{% endcodeblock %}")]),e._v(" "),s("p",[e._v('Essa é uma implementação muito simples do método, não fazemos verificações de nulo por exemplo, mas ela é bem didática. O importante é que com esse método garantimos que um objeto com mesmo nome e idade vai ser sempre considerado igual.\n"Olha, você ta explicando e tal...mas isso pode não dar muito certo... e se o sobrenome for diferente? Não vai ser a mesma pessoa."\nExatamente gafanhoto! Um dos "problemas" em se implementar o equals é garantir que as informações usadas vão garantir que os objetos são os mesmos, por isso a ideia do "valor significativo", cabe ao desenvolvedor decidir isso.')]),e._v(" "),s("p",[e._v("Outra coisa importante é: hashCode e equals andam juntos! Se você implementar um DEVE fazer o mesmo com o outro. não vai dar erro se não o fizer, mas a chance de alguma lógica dar errado por conta disso é muito grande.")]),e._v(" "),s("figure",[s("img",{attrs:{src:"{{ site.url }}/images/tio.jpg",alt:"Mais uma coisa!"}}),e._v(" "),s("figcaption",[e._v('"Mais uma coisa!"')])]),e._v(" "),s("p",[e._v("Segundo a Documentação do Java, o contrato(Regras) de equals() segue as seguintes diretrizes:")]),e._v(" "),s("ul",[s("li",[e._v("É reflexivo: para qualquer valor de referência x, x.equals() deve\nretornar true;")]),e._v(" "),s("li",[e._v("É simétrico: para qualquer valor de referência x e y, x.equals(y) deve retornar true se, e somente se, y.equals(x) retornar true.")]),e._v(" "),s("li",[e._v("É transitivo: para qualquer valor de referência de x, y e z, se x.equals(y) retornar true e y.equals(z) também retornar true, então, x.equals(z) deve retornar true.")]),e._v(" "),s("li",[e._v("É consistente: para qualquer valor de referência de x e y, múltiplas chamadas de x.equals(y) retornarão consistentemente true ou consistentemente false, contanto que nenhuma informação usada nas comparações do objeto de equals tenha sido alterada.")]),e._v(" "),s("li",[e._v("Para qualquer valor de referência x que não seja null, x.equals(null) deve retornar false.")])]),e._v(" "),s("p",[e._v("Como dito, são diretrizes, você não as precisa seguir. Só que sem seguir elas, sua implementação do equals não vai ser eficiente nem vai atender suas necessidades.[siga as diretrizes cara, vai por mim.]")]),e._v(" "),s("p",[e._v('"Angeliski, eu não tenho ideia de como fazer um equals e hashCode!! E agora?"')]),e._v(" "),s("p",[e._v("A maneira mais simples (que pode não ser a mais eficiente) é pedir para a IDE gerar isso pra você. Veja o código gerado para a nossa classe:")]),e._v(" "),s("p",[e._v("{% codeblock lang:java %}\npublic class Pessoa {\nString nome;\nString sobrenome;\nString idade;")]),e._v(" "),s("pre",[s("code",[e._v("@Override\npublic int hashCode() {\n\tfinal int prime = 31;\n\tint result = 1;\n\tresult = prime * result + ((idade == null) ? 0 : idade.hashCode());\n\tresult = prime * result + ((nome == null) ? 0 : nome.hashCode());\n\tresult = prime * result\n\t\t\t+ ((sobrenome == null) ? 0 : sobrenome.hashCode());\n\treturn result;\n}\n\n@Override\npublic boolean equals(Object obj) {\n\tif (this == obj)\n\t\treturn true;\n\tif (obj == null)\n\t\treturn false;\n\tif (getClass() != obj.getClass())\n\t\treturn false;\n\tPessoa other = (Pessoa) obj;\n\tif (idade == null) {\n\t\tif (other.idade != null)\n\t\t\treturn false;\n\t} else if (!idade.equals(other.idade))\n\t\treturn false;\n\tif (nome == null) {\n\t\tif (other.nome != null)\n\t\t\treturn false;\n\t} else if (!nome.equals(other.nome))\n\t\treturn false;\n\tif (sobrenome == null) {\n\t\tif (other.sobrenome != null)\n\t\t\treturn false;\n\t} else if (!sobrenome.equals(other.sobrenome))\n\t\treturn false;\n\treturn true;\n}\n")])]),e._v(" "),s("p",[e._v("}\n{% endcodeblock %}")]),e._v(" "),s("p",[e._v("Por padrão as classes tem a implementação do equals da classe Object, que apenas verifica se os dois objetos tem o mesmo endereço de memória, nem sempre isso é util para nosso código.")]),e._v(" "),s("h2",{attrs:{id:"porque-usar"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#porque-usar","aria-hidden":"true"}},[e._v("#")]),e._v(" "),s("strong",[e._v("Porque usar")])]),e._v(" "),s("p",[e._v("A maior vantagem em sobrescrever esses métodos é melhorar a busca dos objetos. Vamos a um exemplo:")]),e._v(" "),s("p",[e._v("{% codeblock lang:java %}\nimport java.util.List;")]),e._v(" "),s("p",[e._v("public class BuscaPessoa {")]),e._v(" "),s("pre",[s("code",[e._v("public PessoaFisica buscaPessoaPorCpf(List pessoas, String cpf) {\n\n\tfor (PessoaFisica pessoaFisica : pessoas) {\n\t\tif (pessoaFisica.cpf.equals(cpf))\n\t\t\treturn pessoaFisica;\n\t}\n\n\treturn null;\n}\n\nclass PessoaFisica {\n\tString cpf;\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + getOuterType().hashCode();\n\t\tresult = prime * result + ((cpf == null) ? 0 : cpf.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPessoaFisica other = (PessoaFisica) obj;\n\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\treturn false;\n\t\tif (cpf == null) {\n\t\t\tif (other.cpf != null)\n\t\t\t\treturn false;\n\t\t} else if (!cpf.equals(other.cpf))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tprivate BuscaPessoa getOuterType() {\n\t\treturn BuscaPessoa.this;\n\t}\n}\n")])]),e._v(" "),s("p",[e._v("}\n{% endcodeblock %}")]),e._v(" "),s("p",[e._v("Como você pode ver nesse código, temos necessariamente que percorrer a lista para poder localizar nosso objeto, agora vamos ver um modo mais eficiente de fazer isso:")]),e._v(" "),s("p",[e._v("{% codeblock lang:java %}\nimport java.util.List;")]),e._v(" "),s("p",[e._v("public class BuscaPessoa {")]),e._v(" "),s("pre",[s("code",[e._v("public PessoaFisica buscaPessoaPorCpf(List pessoas, String cpf) {\n\tPessoaFisica pessoaFisica = new PessoaFisica();\n\tpessoaFisica.cpf = cpf;\n\tint indexOfPessoa = pessoas.indexOf(pessoaFisica);\n\tif (indexOfPessoa > 0) {\n\t\treturn pessoas.get(indexOfPessoa);\n\t}\n\n\treturn null;\n}\n\nclass PessoaFisica {\n\tString cpf;\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + getOuterType().hashCode();\n\t\tresult = prime * result + ((cpf == null) ? 0 : cpf.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPessoaFisica other = (PessoaFisica) obj;\n\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\treturn false;\n\t\tif (cpf == null) {\n\t\t\tif (other.cpf != null)\n\t\t\t\treturn false;\n\t\t} else if (!cpf.equals(other.cpf))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tprivate BuscaPessoa getOuterType() {\n\t\treturn BuscaPessoa.this;\n\t}\n}\n")])]),e._v(" "),s("p",[e._v("}")]),e._v(" "),s("p",[e._v("{% endcodeblock %}")]),e._v(" "),s("p",[e._v('O método .indexOf da interface List retorna o indice do objeto passado, mas isso se torna "inviável" sem uma implementação correta do equals e hashCode.\nIsso é só uma situação, existem diversos "problemas" acarretados pela não implementação desses métodos, quando usamos uma datatable no JSF existe algumas situações em que os objetos se comportam de modo incorreto graças a falta dos métodos sobreescritos.')]),e._v(" "),s("figure",[s("img",{attrs:{src:"{{ site.url }}/images/isso-e-tudo.jpg",alt:"Isso é tudo pessoal!"}}),e._v(" "),s("figcaption",[e._v('"Isso é tudo pessoal!"')])]),e._v(" "),s("p",[e._v("Duvidas? gostou? Me acha um idiota?")]),e._v(" "),s("p",[e._v("Comenta ai!!")]),e._v(" "),s("p",[e._v("Angeliski")]),e._v(" "),s("p",[e._v("Referências:")]),e._v(" "),s("p",[s("a",{attrs:{href:"http://migre.me/hiDcu",title:"Ensinando o que é hashCode - Caelum",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ensinando o que é hashCode - Caelum"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"http://migre.me/hiDdS",title:"Tabela de Dispersão - Wikipedia",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tabela de Dispersão - Wikipedia"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"http://migre.me/hiDik",title:"Tabela de Espalhamento - Caelum",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tabela de Espalhamento - Caelum"),s("OutboundLink")],1),e._v(" (muito bom!! Recomendadíssimo!)")])])}),[],!1,null,null,null);a.default=t.exports}}]);